# -*- coding: utf-8 -*-
"""
Created on Fri Aug 24 09:40:28 2018

@author: Paulo Augusto
"""

import numpy as np
#from numpy import fft
import matplotlib.pyplot as plt
#import scipy.signal as sig
import os
import random 
import emgReaderClass_v2 as erc
import threading
import multiprocessing
#import dataPlotter
import snkbrain
import scipy.stats as st
import cProfile
import re


                    # This script is compatible with 'emgReaderClass_v2', that
                    # reads the .csv files generated by 'movementSaver.m', from
                    # the folder './csv/'
profiling=False
    
bias=0              # If bias = 1, every cromossome will have a non frequency dependant DNA
maxGen=2000      # The max number of generations
startOver=True# If True, the code will not consider the last simulation
tamPop=30      # Population number

maxFreq=180        # This is the max Frequency to consider #240
freqStep=3         # For freqStep=3 -> The code will consider [1,2,3],[3,4,5], etc# 3

taxaMut=0.01        # The mutation rate
taxaMutMin=0.01     # Minimum mutation rate
taxaMutMax=5.0     # Maximum mutation rate
chanceMut=60        # The chance of mutation/10000 (only for the "absolute" mutation)

bestTypes=[]        # Logging variable

continuous=True    # If True, the code will use a continuous fitness function (not recommended)
binaryFit=False     # If True, the fitness of each individual will be 1 for each right guess
                    # If False, it will be continuous if "continuous" is True, or 1 point if
                    # it guesses correctly, and 1.5 if it guesses with an confidence above 
                    # a "multFac" threshold
multFac=1.5         # 
binaryCrossChance=0.5           # The chance of ocurring a binary cross. 1 minus this 
                                # is the chance of ans mean crossing
vectorialMutationChance=0.5     # The chance of vectorial mutation. 1 minus this is 
                                # chance of an absolute mutation

taxaMutMult=4.0                 # The factor by which taxaMut will be multiplied
initialModule=1                # Initial module of cromossome values

sourceType='ninapro'
ninaprofolders=['csv1','csv2','csv3','csv6','csv7','csv8']
fs=2000
##############################################################################
guid=0                          # Individual ID (logging variable)

param=[]
real=[]                         # DATA
origin=[]                       # DATA
fv=[]                           # DATA
frv=[]                          # DATA
nArq=0                          # DATA


# lastValues, botThs and topThs to be used in each archive
parameters={'bicepsinteiro.txt': [400,20,10],\
            'bicepsmetade.txt': [400,20,10],\
            'emgwk.txt': [400,20,10],\
            'emgmed.txt':[400,20,10],\
#            'xoxoxo.txt':[300,40,30],\
            'emgabrindo.txt':[500,20,20],\
            'emgapertando.txt':[400,20,20]}


curtose = st.kurtosis
obliquidade = st.skew
variancia = np.var
media = np.mean
desvio_padrao = np.std

def rms(v):
    temp=sum([pow(i,2) for i in v])
    return np.sqrt(temp/len(v))
def centroide_espectral(v):
#    tam=len(v)
#    *fs/tam
    global fs
    max_freq=240
    min_freq=6
    max_i=int(max_freq*len(v)/fs)
    min_i=int(min_freq*len(v)/fs)
    temp=v[min_i:max_i]
    temp = sum([i*value for i,value in zip(range(1,1+len(temp)),temp)])
    soma = sum(temp)
    return float(temp)/soma
def feature_scaling(v):
    mean = np.mean(v)
    temp = [a-mean for a in v]
    return temp/desvio_padrao(v)

def get_parameters(timeValues,freqValues):
    maxt=np.max(timeValues)
    maxf=np.max(freqValues)
#    freq=[a*2/(len(freqValues)) for a in freqValues]
#    tyme=[a/(1000) for a in timeValues]

    freq=[a*2/(maxf) for a in freqValues]
    tyme=[a/(maxt) for a in timeValues]
    temp=[curtose(tyme),
          obliquidade(tyme),
          variancia(tyme),
          media(tyme),
          desvio_padrao(tyme),
          rms(tyme),
          curtose(freq),
          obliquidade(freq),
          variancia(freq)/1000,
          media(freq),
          desvio_padrao(freq),
          rms(freq)]
    return temp
    
## Method that return the number of right guesses of and individual
#def countGuesses(indiv):
#    
#
#    score=0
#    
#    for arq in range(0,nArq):
#      
#        for i in range(0,len(real[arq])):
#            tam=len(real[arq][i])
#            
#            x= getFreqVector(fv[arq][i])
#            x=np.array(x)
#            
#            pont=x*indiv.cromo.freqFactor
##            test.append(pont)
#            
#            if np.argmax(pont[0]) == arq:
#
#                score+=1
#    
#    return score
#
## This function just multiplies the chromossome of an individual by the frequency
## vector of an signal, return the result. The position that gets the higher
## number represent from which archive it thinks this signal belongs
#def sayWho(indiv,real,fv):
#    tam=len(fv)
#    x= getFreqVector(fv)
#    x=np.array(x)
#    pont=x*indiv.cromo.freqFactor
#    return pont
    
# Gets the *.txt files
def getArqs():
    arqVec=[]
    for arq in os.listdir('.'):
        if os.path.splitext(arq)[1]=='.txt':
            arqVec.append(arq)
    arqVec.reverse()
    return arqVec

# Individual class
class ind:
    def __init__(self):
        global guid
        self.uid=guid
        guid+=1
        self.fit=-1000
        self.marker='none'
        self.brain=snkbrain.brain([12,12,6],[1,1,0])

def getParameters():
    global param
    param=[[feature_scaling(get_parameters(realV,freqV)) for realV,freqV in zip(sr,sf)] for sr,sf in zip(real,frv)]
    
# This function takes the fft data od an signal, and returns a similar vector,
# but instead of getting one element per frequency it take a number of freqStep
# frequencies, sum it and divide by freqStep
def getFreqVector(fv):
    x=[]
    tam=float(len(fv))
    norm=int(np.ceil(tam*1/fs))
    step=freqStep*norm
    for j in range(0,norm*maxFreq,step):
        x.append(sum(fv[j:j+step])*2/tam)
        ##### BIAS ######
        if bias==1 and j==step*maxFreq-1:
            x.append(-1)
        #################
    return x


# Read the data archives. The original signal is stored in origin. Each signal
# Is stored in real. real[arq][5] will contain the 5th signal of the arq'th file
# (as read by getArqs). The fft data will be stored at "fv" (indexes works the
# the same as for "real"). The frequency vector as got by getFrequencyVector
# is stored at frv
def readArqs(source,muscle,interval):
    it=interval
    reader=erc.emgReader()
    arqVec=getArqs()
    nArq=len(arqVec)
    global real,fv,frv
    if source=='bioplux':
        print nArq
        for arq in range(0,nArq):      
            origin.append([])
            real.append([])
            fv.append([])
            frv.append([])
            
            reader.lastValues=parameters[arqVec[arq]][0]
            reader.topThs=parameters[arqVec[arq]][1]
            reader.botThs=parameters[arqVec[arq]][2]
            
            origin[arq],real[arq],fv[arq] = reader.analyzeEmg(arqVec[arq],fs)
            
    elif source=='ninapro':
        global ninaprofolders
        realt,fvt=[],[]
        for folder in ninaprofolders:
            realt.append([])
            fvt.append([])
            realt[-1],fvt[-1]=reader.getCsvData(muscle,folder)
        
        for arq in range(0,len(realt[0])):
            real.append([])
            fv.append([])
           
            for r,f in zip(realt,fvt):                        
                real[arq].extend(r[arq][ it[0]:it[1] ])
    #            real[arq].extend(real2[arq][ it[0]:it[1] ])
    #            real[arq].extend(real3[arq][ it[0]:it[1] ])
    #            real[arq].extend(real6[arq][ it[0]:it[1] ])
    #            real[arq].extend(real7[arq][ it[0]:it[1] ])
    #            real[arq].extend(real8[arq][ it[0]:it[1] ])
    
                fv[arq].extend(f[arq][ it[0]:it[1] ])
    #            fv[arq].extend(fv2[arq][ it[0]:it[1] ])
    #            fv[arq].extend(fv3[arq][ it[0]:it[1] ])
    #            fv[arq].extend(fv6[arq][ it[0]:it[1] ])
    #            fv[arq].extend(fv7[arq][ it[0]:it[1] ])
    #            fv[arq].extend(fv8[arq][ it[0]:it[1] ])

        training=[18-1,21-1,22-1,25-1,26-1,31-1]
        real=[real[i] for i in training]
        fv=[fv[i] for i in training]
        
    for arq in range(0,len(real)):      
        frv.append([])
        for i in range(0,len(fv[arq])):
            frv[arq].append(getFreqVector(fv[arq][i]))

# Fitness method. Each signal frequency vector is multiplied by indiv
# chromossome. The numbers got are reconized as the score of each archive.
# Let's say that the 0th element gets the largest number. That mean this 
# individual "thinks" that that signal belongs to archive 4 (getArqs()[0])
# The fitness is then calculated by the number of right guesses of each
# individual
            
def fitness(indiv):
    
    global nArq
    score=0
    for arq in range(0,len(real)):
      
        for i in range(0,len(fv[arq])):
            tam=len(real[arq][i])
            
#            inpt=frv[arq][i]
            inpt=param[arq][i]

            l,pont= indiv.brain.run(inpt)#np.array(frv[arq][i])*indiv.cromo.freqFactor
            
            def error(pont,ref):
                score=0
                for i in range(0,len(pont)):
                    if i==ref:
                        t=1
                    else:
                        t=0
                    score+= t * np.log(pont[i]) + (1-t) * np.log(1-pont[i])
#                    score+= t*np.log((pont[i]+1)/2)+(1-t)*np.log(1-(pont[i]+1)/2)

                return score
            if True:
                score+=error(pont,arq)
            else:
                maxIndex= np.argmax(pont)
                if  maxIndex == arq:
                    if not binaryFit:
    ###############################################################################
                        if continuous:
                            score+=pont[maxIndex]
    ###############################################################################
                        else:
                            if np.max(np.array(pont)) >=multFac*np.mean(np.array(pont)):
                                score+=1.5
                            else:
                                score+=1
    ###########################################################################
                    else:
                        score+=1
    return score
    
# Population class
class population:
    def __init__(self):
        self.population=[]

    def initPop(self,tamPop):
        for i in range(0,tamPop):
            self.population.append(ind())
    def evaluateAll(self):
        for ind in self.population:
            ind.fit=fitness(ind)        
    def getBest(self):
        return self.population[np.argmax(self.population)]
            # Mutation method. The mutation can be vetorial or absolute.
def mutate(indiv):

    global taxaMut,chanceMut
    
    if random.random()<vectorialMutationChance:
        vec= ind()#tknake.snake(indiv.root,x=0,y=0,lenght=indiv.lenght,width=indiv.width,segDis=indiv.segmentDistance).brainMatrixes
        
        for indivLayer,layer in zip(indiv.brain.brainMatrixes,vec.brain.brainMatrixes):
            amp=np.sqrt(sum([sum([pow(i,2) for i in line.A1])  for line in layer]))
            layer/=amp
            layer*=taxaMut
            indivLayer+=layer
 
#        for i in range(0,len(vec.brain.biasMatrix)):
#            soma=sum(vec.brain.biasMatrix[i])
#            for j in range(0,len(vec.brain.biasMatrix[i])):
#                vec.brain.biasMatrix[i][j]*=taxaMut/soma
#                indiv.brain.biasMatrix[i][j]+=vec.brain.biasMatrix[i][j]
                
        indiv.marker='vectorial'

    else:
        for layer in indiv.brain.brainMatrixes:
            for line in layer:
                for value in line.A1:    
                    if random.random()*10000<chanceMut:
                        mut=(2*random.random()-1)*taxaMut
                        value+=mut
                        
#        for i in range(0,len(indiv.brain.biasMatrix)):
#            for j in range(0,len(indiv.brain.biasMatrix[i])):
#                 if random.random()*10000<chanceMut:
#                        mut=(2*random.random()-1)*taxaMut
#                        indiv.brain.biasMatrix[i][j]+=mut
                        
    
        indiv.marker='absolute'
# Crossover by adding different chromossomes and dividing by the number of
# fathers
def meanCrossover(pais):
    
    filho= ind()
    
    soma=[]
    soma = [sum([pai.brain.brainMatrixes[i] for pai in pais]) for i in range(0,len(pais[0].brain.brainMatrixes))]
    tam= len(pais)
    filho.brain.brainMatrixes=[mtx/tam for mtx in soma]
    
    
#    for i in range(0,len(pais[0].brain.biasMatrix)):
#        for j in range(0,len(pais[0].brain.biasMatrix[i])):
#            soma=sum([pai.brain.biasMatrix[i][j] for pai in pais])/len(pais)
#            filho.brain.biasMatrix[i][j]=soma
            
    mutate(filho)
    filho.marker+=' meaned '
    
    return filho

# Crossover by replacing the sons genes by his mother's or his father's, with 
# 50% chance
def binaryCrossover(pais):
    filho= ind()#tknake.snake(pais[0].root,x=0,y=0,lenght=pais[0].lenght,width=pais[0].width,segDis=pais[0].segmentDistance)
    for i in range(0,len(filho.brain.brainMatrixes)):
        for j in range(0,len(filho.brain.brainMatrixes[i])):
            for k in range(0,len(filho.brain.brainMatrixes[i][j])): 
                if random.random()<0.5:
                    filho.brain.brainMatrixes[i][j,k]=pais[0].brain.brainMatrixes[i][j,k]
                else:
                    filho.brain.brainMatrixes[i][j,k]=pais[1].brain.brainMatrixes[i][j,k] 
    
#    for i in range(0,len(pais[0].brain.biasMatrix)):
#        for j in range(0,len(pais[0].brain.biasMatrix[i])):
#            if random.random()<0.5:
#                filho.brain.biasMatrix[i][j]=pais[0].brain.biasMatrix[i][j]
#            else:
#                filho.brain.biasMatrix[i][j]=pais[1].brain.biasMatrix[i][j]
    
    mutate(filho)
    filho.marker+=' binerized '                  
    return filho          

# Mixed crossover
def weightedCrossover(pais):
    if random.random()<binaryCrossChance:
        return binaryCrossover(pais)
    else:
        return meanCrossover(pais)


# Tournament. Returns the best fitted individual
def torneio(pop):
    
    bestIndiv=pop.population[0]
    for indiv in pop.population:
        if indiv.fit>=bestIndiv.fit:
            bestIndiv=indiv
    return bestIndiv
        
# Generate a new population by performing crossovers with best and the reminder
# population
def genNewPop(best,pop):   
    newpop=population()
    for indiv in pop.population:
        if indiv == best:
            newpop.population.append(indiv)
            continue
        else:
            temp=weightedCrossover([best,indiv])
            newpop.population.append(temp)
    return newpop

# Remove the n less fitted individuals, replacing them by new ones
def removeSuckers(pop,n):
    
    def getFit(indiv):
        return indiv.fit
    pop.population.sort(reverse=False,key=getFit)
    for i in range(0,n):
        pop.population[i]=ind()
        pop.population[i].marker= 'new'
        
# Returns the mean fitness of poppulation in pop
def getPopMean(pop):
    temp=0.0
    tam=len(pop.population)
    for indiv in pop.population:
        temp+=indiv.fit
    return temp/tam

## Not used. Divide all chromossomes of a population by the highest number 
## amongst them
#def normalizePop(pop):
#    for indiv in pop.population:    
#        maxF=0    
#        for line in indiv.cromo.freqFactor:
#            for i in range(0,len(np.array(line)[0])):        
#                if abs(line[0,i]) > maxF:
#                    maxF=abs(line[0,i])
#                
#        for line in indiv.cromo.freqFactor:
#            for i in range(0,len(np.array(line)[0])):        
#                line[0,i]/=maxF
    
# Plot a graph
def plotGens(best,mean):
    plt.plot(best,'go')
    plt.plot(mean,'b-')

# Class for controlling the GA variables
class populationControl():
    global  tamPop,\
            taxaMut,\
            chanceMut,\
            bestAll,\
            bias,\
            maxGen,\
            tamPop,\
            taxaMut,\
            taxaMutMax,\
            chanceMut,\
            continuous,\
            binaryFit,\
            multFac,\
            binaryCrossChance,\
            taxaMutMult,\
            taxaMutMin

    def __init__(self):
        self._tamPop=tamPop
        self._taxaMut=taxaMut
        self._chanceMut=chanceMut
        self._bias=bias
        self._maxGen=maxGen
        self._tamPop=tamPop            
        self._taxaMutMin=taxaMutMin
        self._taxaMutMax=taxaMutMax
        self._chanceMut=chanceMut
        self._continuous=continuous
        self._binaryFit=binaryFit
        self._multFac=multFac
        self._binaryCrossChance=binaryCrossChance
        self._taxaMutMult=taxaMutMult
        self._counter=0
        self._expansion=False
  
    def control(self,gen,counter,best,last):
        global taxaMut
#        taxaMut=self._taxaMutMax
        ascendingCounter=0
        if gen>25:
            if best.fit<=last.fit*1.001: #If the fitness doesnt grow by 0.1%
                self._counter+=1
            else:
    #            taxaMut=self._taxaMut
                chanceMut=self._chanceMut
                self._expansion=False
                self._counter=0
                ascendingCounter=0
                
            
            if self._counter==10:    # If the fitness doesnt grow in n generations
                if self._expansion: # If it the taxaMut is increasing 
                    if taxaMut<self._taxaMutMax:    # If taxaMut is less than the maximum
                        taxaMut*=self._taxaMutMult

                    else:           # If taxaMut bigger than the maximum
                        self._expansion=False
    
                else:               # If taxaMut is decreasing
                    if taxaMut>self._taxaMutMin:    # If it is bigger than the minimum
                        taxaMut/=self._taxaMutMult
                    else:                           # If it is less than the minimum
                        self._expansion=True    
                
                self._counter=0  
                

def main():
    
    global  maxFreq,\
            freqStep,\
            tamPop,\
            taxaMut,\
            chanceMut,\
            nArq,\
            bestAll,\
            startOver,\
            bestTypes
                    
    gen=0
    counter=0
    last=ind()
    bestVec=[]
    meanVec=[]
    taxaVec=[]
    taxaMut=taxaMutMax



#    plotter=dataPlotter.dataPlotter('Geracao','Melhor de Todos',bestVec)
#    threading.Thread(target=plotter.start).start()
    controller=populationControl()
    

    
    if sourceType=='bioplux':
        nArq=len(getArqs())
    elif sourceType=='ninapro':
        nArq=len(real)
    else:
        1
        
    if startOver:
        readArqs(sourceType,'flx',[0,3])
        getParameters()
        pop = population()
        pop.initPop(tamPop)
    else:
        print 'Didnt start over'
        pop=bestAll
    while gen<maxGen:
        gen+=1
        pop.evaluateAll()
        removeSuckers(pop,tamPop/3)
        best=torneio(pop)
        if not last.uid==best.uid:
            bestTypes.append(best.marker)
            
        print(gen,best.fit,':',best.marker,tamPop,taxaMut,chanceMut,maxGen)#,':', [p.fit for p in population]
        pop=genNewPop(best,pop)
    ###########################################################################
        controller.control(gen,counter,best,last)
        last=best
        
        taxaVec.append(20*np.log(taxaMut))
        bestVec.append(last.fit)
        meanVec.append(getPopMean(pop))
        bestAll=pop

    ###########################################################################
#        createSuckers(pop.tamPop/3)
        
#        normalizePop(pop)
    
    plotGens(bestVec,meanVec)
    plotGens(bestVec,taxaVec)
    pop.evaluateAll()
    print([p.fit for p in pop.population])
    
    return pop

def trainSomeone(indiv,number,learning_rate):
    count=0
    while count<number:
        for arq in range(0,len(real)):
            for i in range(0,len(fv[arq])):
                target=[0.001,0.001,0.001,0.001,0.001,0.001]
                target[arq]=0.999
                indiv.brain.train(param[arq][i],target,learning_rate)
        count+=1
        
# Ver acertos
#score=0
#total=0
#for arq in range(0,len(real)):
#    for i in range(0,len(fv[arq])):
#        total+=1
#        l,o=bestAll.population[tamPop-1].brain.run(param[arq][i])
#        if np.argmax(o)==arq:
#            score+=1
#print score,' de ',total

#Treinar
#last=-100
#count=0
#lr=0.01
#errorcount=0
#flag=0
#while fitness(bestAll.population[tamPop-2])<-17:
#    f=fitness(bestAll.population[tamPop-2])
#    if last>f:
#        lr/=1.1
#        errorcount+=1
#    else:
#        count+=1
#    if count==11:
#        lr*=1.03
#        count=0
#    if errorcount==3:
#        if flag>=3:
#            print 'to many errors'
#            break
#        else:
#            flag+=1
#            lr=0.01
#            errorcount=0
#    trainSomeone(bestAll.population[tamPop-2],50,lr)
#    last = f    
#    print f,lr
        
def treinar(ind,init_lr,goal):
    global bestAll,tamPop
    last=-1000
    count=0
    lr=init_lr
    errorcount=0
    flag=0
    f=-1000
    lastbrain=[a.copy() for a in ind.brain.brainMatrixes]
    while f<goal:
        f=fitness(ind)

        if last>f:
            lr/=1.1
            errorcount+=1
            ind.brain.brainMatrixes=lastbrain
        else:
            lastbrain=[a.copy() for a in ind.brain.brainMatrixes]
            errorcount=0
            count+=1
        if count==11:
            lr*=1.03
            count=0
        if errorcount==3:
            if flag>=3:
                print 'to many errors'
                break
            else:
                flag+=1
                lr=init_lr
                errorcount=0
        trainSomeone(ind,100,lr)
        last = f    
        print f,lr
    return lr

def treinar_r(ind,goal):
    global bestAll,tamPop
    last=-1000
    count=0
    lr=0.01
    min_lr=0.00001
    max_lr=0.01
    errorcount=0
    assertcount=0
    descended=False
    flag=0
    lastbrain=[a.copy() for a in ind.brain.brainMatrixes]
    bestbrain=[a.copy() for a in ind.brain.brainMatrixes]
    bestfit=last
    while fitness(ind)<-goal:
        trainSomeone(ind,20,lr)
        f=fitness(ind)
        if f>bestfit:
            bestfit=f
            bestbrain=[a.copy() for a in ind.brain.brainMatrixes]
        if last>f:
            ind.brain.brainMatrixes=last_brain
            if descended:
                lr/=1.12
                if lr<=min_lr:
                    print 'Too much errors'
                    return bestbrain,lr
            else:
                lr/=1.1
                if lr<=min_lr:
                    lr=max_lr
                    descended=True
        else:
            last_brain=[a.copy() for a in ind.brain.brainMatrixes]
            assertcount+=1
            descended=False
#        if assertcount==10:
#            assertcount=0
#            lr*=1.03
        last = f   
        print f,lr
    return lr

if profiling:
    cProfile.run('main()')
else:
    1
#    main()
